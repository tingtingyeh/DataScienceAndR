- Class: meta
  Course: DataScienceAndR
  Lesson: Optional-RProgramming-02-Function-Introduction
  Author: Wush Wu
  Type: Standard
  Organization: Taiwan R User Group
  Version: 1.0

- Class : text
  Output: |
    這門課程想要跟同學介紹如何在R 中建立自己的函數。

- Class : text
  Output: |
    在R 中，已經有很多方便的工具，例如`mean`、`sd`等幫助使用者計算平均值、標準差的「函數」。
    然而，R 也可以讓使用者建立自己的函數。

- Class : text
  Output: |
    舉例來說，有一個矩陣`m` 和一個向量`y` ，我們想要找到一個向量`x`，讓`m %*% x`很靠近`y`。
    這裡的`m` 是根據過去經驗所蒐集的資訊，而`y` 則是我們感興趣、想預測、或是想要了解其變化規則的數字。
    舉例來說，若想要了解車速及剎車滑行距離間的關係，並給出在特定的車速之下，建議車輛與前車之間所需要保持的安全距離。
    在上述的例子˙中，`m` 即為車速，而`y` 則是煞車的滑行距離。
    

- Class : cmd_question
  Output: |
    首先我們先看看m 的值。請同學輸入`m`。
    
    
- Class : cmd_question
  Output: |
    我們再看看y 的值。請同學輸入`y`。
    
    
- Class : cmd_question
  Output: |
    因為`m` 是一個50 * 2 的矩陣，所以只要在R 裡面找一個長度為2 的向量，例如`c(-17, 4)` ，我們就可以用`m %*% c(-17, 4)`來當作是對y 的趨近。
    請同學算算看`m %*% `c(-17, 4)`。
  CorrectAnswer: m %*% c(-17, 4)
  AnswerTests: omnitest("m %*% c(-17, 4)")

- Class : cmd_question
  Output: |
    接著我們來評估`c(-17, 4)`是不是一個夠好的答案。
    請同學計算`m %*% c(-17, 4) - y`的平方的和(Sum of Square)。
  CorrectAnswer: sum((m %*% c(-17, 4) - y)^2)
  AnswerTests: omnitest(correctVal = sum((m %*% c(-17, 4) - y)^2))

- Class : cmd_question
  Output: |
    通常在比較這個指標的時候，我們可以拿`mean(y) - y`的平方的和作為一個參考值。
    而因為`y` 的平均是趨近y 最普通的一種方式，所以我們對`y` 的逼近應該要比`mean(y)`來的好。
    請同學以`mean(y) - y`的平方和進行計算。
  CorrectAnswer: sum((mean(y) - y)^2)
  AnswerTests: omnitest(correctVal = sum((mean(y) - y)^2))

- Class : mult_question
  Output: |
    請問同學，`m %*% c(-17, 4)`和`mean(y)`，哪一個趨近`y` 的效果比較好？（以誤差的平方和來評估）
  AnswerChoices: m %*% c(-17, 4);mean(y)
  CorrectAnswer: m %*% c(-17, 4)
  AnswerTests: omnitest(correctVal = "m %*% c(-17, 4)")

- Class : text
  Output: |
    在進行上面兩個計算時，同學重複計算兩次和`y` 相差的平方和。
    這樣重複的計算，在R 中是可以透過「撰寫函數」來簡化的。
    我們可以建立一個R 的函數物件`f` ，將上述的兩個計算的程式碼從`sum((<???> - y)^2)`變成`f(<???>)`。

- Class : cmd_question
  Output: |
    請同學輸入`f <- function(x) sum((x - y)^2)`。
  CorrectAnswer: f <- function(x) sum((x - y)^2)
  AnswerTests: omnitest("f <- function(x) sum((x - y)^2)")

- Class : cmd_question
  Output: |
    我們先試試看`f` 的效果。
    請同學輸入`f(m %*% c(-17, 4))`來看看得到的答案是否和`sum((m %*% c(-17, 4) - y)^2)`所得出的答案相符，即為11491。
  CorrectAnswer: f(m %*% c(-17, 4))
  AnswerTests: omnitest("f(m %*% c(-17, 4))")

- Class : cmd_question
  Output: |
    接著請同學輸入：`f(mean(y))`來看看答案是否和`sum((mean(y) - y)^2)`所得出的答案相符，即為32538.98。
  CorrectAnswer: f(mean(y))
  AnswerTests: omnitest("f(mean(y))")

- Class : text
  Output: |
    我們來解釋一下：`f <- function(x) sum((x - y)^2)`的效果。
    當我們輸入：`f(mean(y))`時，R 就會進入到「函數的領域」（行話叫做「環境」，這部份在未來的RProgramming 課程中會有細部的解釋）
    `mean(y)`是`f`的第一個參數，也就是x ，R 在計算`sum((x - y)^2)` 時，會用`mean(y)` 的值替換`x` ，因此能得出和`sum((mean(y) - y)^2)`一樣的計算結果。

- Class : mult_question
  Output: |
    同樣的道理，R 在計算`f(m %*% c(-17, 4))` 時，他會拿某個運算結果代入`sum((x - y)^2)`的`x` 。
    請問同學，下列哪一個是R 代入`x` 所得出的運算結果呢？
  AnswerChoices: m;c(-17, 4);m %*% c(-17, 4)
  CorrectAnswer: m %*% c(-17, 4)
  AnswerTests: omnitest(correctVal = "m %*% c(-17, 4)")

- Class : text
  Output: |
    透過`f` ，我們可以很輕鬆的計算估計誤差的平方和。

- Class : cmd_question
  Output: |
    回到原本的問題，我們想要找一個長度為2 的向量，讓m 和這個向量相乘後，可以很接近y 。
    可是`f` 的參數`x`所代表的意義已經是對`y` 的估計了，這樣在使用上還是不夠方便。
    我們可以利用`f`來建立更方便的計算函數。
    請同學輸入：`f1 <- function(x) f(m %*% x)`。
  CorrectAnswer: f1 <- function(x) f(m %*% x)
  AnswerTests: omnitest("f1 <- function(x) f(m %*% x)")

- Class : cmd_question
  Output: |
    請同學輸入：`f1(c(-17, 4))`，是不是再次得到一樣的答案：11491呢？
    但是這一次，我們輸入的程式碼更短了。
  CorrectAnswer: f1(c(-17, 4))
  AnswerTests: omnitest("f1(c(-17, 4))")

- Class : cmd_question
  Output: |
    請同學輸入`f1(c(1, 1))`，這次我們可以很快的確認拿`m %*% c(1, 1)` 逼近`y` 後得到的結果夠不夠好。
  CorrectAnswer: f1(c(1, 1))
  AnswerTests: omnitest("f1(c(1, 1))")

- Class : mult_question
  Output: |
    將`f1(c(1, 1))` 的結果與`f(mean(y))`的答案32538.98相比，請問哪一個逼近的效果比較好？
  AnswerChoices: m %*% c(1,1);mean(y)
  CorrectAnswer: mean(y)
  AnswerTests: omnitest(correctVal = "mean(y)")

- Class : text
  Output: |
    一般來說，如果要靠瞎猜，猜到一組參數`x`讓`m %*% x`的估計比`mean(y)`好也不是一件太容易的事。

- Class : text
  Output: |
    另外，我們剛剛透過定義`f` 和`f1`來簡化重複的動作。
    當我們在撰寫複雜的程式時，這類簡化的動作可以有效地提升工作效率。
    函數的設計，在近代軟體工程的領域中，也是有許多好的規範。
    這份教材只是介紹R 的函數功能，如果未來同學有需要寫複雜的R 程式，建議還是查查相關的資料後再動手，會讓自己的工作效率更高。

- Class : cmd_question
  Output: |
    在R 之中，我們可以利用`optim` 來尋找一個函數的最小值。
    請同學輸入：`optim(c(0,0), f1)`並且將結果儲存到變數`r` 之中。
    我們先讓同學玩一玩`r`之後，再解釋`optim`。
    這段嘗試過程的設計，也是我們使用R 強大的計算功能後所得到的結果。
  CorrectAnswer: r <- optim(par = c(0,0), f1)
  AnswerTests: any_of_exprs("r <- optim(c(0,0), f1)",
    "r = optim(c(0,0), f1)")

- Class : cmd_question
  Output: |
    這裡的optim 函數很厲害，可以找到一個向量，讓`f1` 的輸出達到最小。
    這些資訊現在都在變數`r` 之中。
    請同學先檢查一下`r` 的型態。
  CorrectAnswer: class(r)
  AnswerTests: omnitest("class(r)")

- Class : cmd_question
  Output: |
    接著，請同學列出所有`r`元素的名稱。
  CorrectAnswer: names(r)
  AnswerTests: omnitest(correctVal = names(r))

- Class : cmd_question
  Output: |
    請同學輸入`?optim`讀一讀`optim` 的說明，下一個問題將會需要參考Value 這個段落中的說明文字。
  CorrectAnswer: ?optim
  AnswerTests: any_of_exprs("?optim", 'help("optim")')

- Class : mult_question
  Output: |
    請問同學，哪一個`r` 的元素代表著產生最小值的`beta`？
  AnswerChoices: par;value;counts;convergence;message
  CorrectAnswer: par
  AnswerTests: omnitest(correctVal = "par")

- Class : mult_question
  Output: |
    我們回來看看原先計算`r` 的程式碼：`optim(c(0,0), f1)`。
    請問同學，`c(0, 0)`對應到`optim`這個函數的哪一個參數呢？請參考optim 的說明文件作答。
  AnswerChoices: par;fn;gr;method;lower;upper;control
  CorrectAnswer: par
  AnswerTests: omnitest(correctVal = "par")
  Hint: R 在判斷函數的時候：「有名字的用名字、沒名字的用順序」

- Class : text
  Output: |
    另外一個R 很重要的特色是，函數本身也是一種物件。
    R 其實是「函數式語言」，而這是所有函數式語言的一個重要特色。
    所以，函數可以被當成參數，供給另外一個函數的。

- Class : mult_question
  Output: |
    請問同學，在`optim(c(0,0), f1)`中，`f1`對應到`optim`這個函數的哪一個參數呢？
    請參考optim 的說明文件作答。
  AnswerChoices: par;fn;gr;method;lower;upper;control
  CorrectAnswer: fn
  AnswerTests: omnitest(correctVal = "fn")
  Hint: R 在判斷函數的時候：「有名字的用名字、沒名字的用順序」

- Class : cmd_question
  Output: |
    請問`f1`的型態（class）是什麼？
  CorrectAnswer: class(f1)
  AnswerTests: omnitest(correctVal = class(f1))

- Class : text
  Output: |
    在`optim`的範例中，我們利用`f1`告訴R 我們所在乎的指標（也就是透過和`m` 做相乘後與`y` 的差別），
    這裡的`f1`是一個動態的運算：R 每猜一個數，例如`c(0,0)`的值，就會用`f1` 來評估猜的結果夠不夠好。
    透過演算法的最佳化，R 就可以找到最好的猜測。

- Class : cmd_question
  Output: |
    請同學輸入`r$par`看看`optim` 所找到的最佳解。
  CorrectAnswer: r$par
  AnswerTests: omnitest("r$par")

- Class : cmd_question
  Output: |
    讓我們用迴歸分析的方法找到最好的解。
    請同學輸入`solve(t(m) %*% m, t(m) %*% y)`。
  CorrectAnswer: solve(t(m) %*% m, t(m) %*% y)
  AnswerTests: omnitest("solve(t(m) %*% m, t(m) %*% y)")

- Class : text
  Output: |
    找到的解是不是非常接近呢？

- Class : text
  Output: |
    以上就是對於R 的函數功能的簡單簡介。
